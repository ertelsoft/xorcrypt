0 Referenzen

[AES]      FIPS PUB 197 "Announcing the ADVANCED ENCRYPTION STANDARD (AES)", 26.11.2001

[CTR]      NIST Special Publication 800-38A "Recommendation for Block Cipher Modes of Operation,
           Methods and Techniques", 2001

[SHA]      FIPS PUB 180-4 "Secure Hash Standard (SHS)", August 2015

[HMAC]     FIPS PUB 198-1 "The Keyed-Hash Message Authentication Code (HMAC)", Juli 2008

[PBKDF2]   NIST Special Publication 800-132 "Recommendation for Password-Based Key Derivation,
           Part 1: Storage Applications", Dezember 2010





1 Überblick

XorCrypt ist in erster Linie ein minimalistisches Format für eine Passwort-basierte Datei-Verschlüsselung, welche
Vertraulichkeit und Integrität einer Datei sicherstellt. Als Algorithmen sind AES-256 im Counter-Modus (Verschlüsselung)
und SHA-256 im HMAC-Modus (Integritätssicherung) festgelegt. Entsprechende Schlüssel werden per SHA-256 basiertem PBKDF2
Algorithmus aus dem Passwort abgeleitet.

Unabhängig von der Format-Spezifikation existiert eine Implementierung, das Tool XorCrypt. Dieses erlaubt es, Dateien
im XorCrypt-Format zu ver- und entschlüsseln. Es steht als Quellcode für Debian-basierte Linux-Betriebssysteme zur Verfügung
und kann dort als Kommandozeilen-Applikation gebaut und verwendet werden.



2 XorCrypt-Format

2.1 Eigenschaften

Bei der Spezifikation von XorCrypt wurden folgende Ziele verfolgt:
- Es sollte ein möglichst einfaches, übersichtliches Format sein.
- Die Verschlüsselung sollte Passwort-basiert sein.
- Tools zur Ver- und Entschlüsselung sollten ohne großen Aufwand implementierbar sein.
- Es sollte aktuellen kryptografischen Sicherheitsanforderungen genügen, d.h. möglichst
  von niemandem auf dieser Welt knackbar sein (unter der Vorraussetzung eines entsprechend
  lang gewählten Passwortes).
- Es sollte auf standardisierten kryptografischen Verfahren basieren.
- Die Entschlüsselung sollte nicht zu einer Fehlerfortpflanzung führen, d.h ein
  gekipptes Bit im Chiffrat sollte auch nur ein gekipptes Bit im entschlüsselten
  Klartext zur Folge haben.
- Das Format sollte als solches nicht identifizierbar sein. D.h. eine verschlüsselte
  Datei sollte nicht von einem Zufalls-Bytestrom unterscheidbar sein.


2.2 Spezifikation

2.2.1 Datei-Aufbau

Eine XorCrypt verschlüsselte Datei besteht aus 3 Teilen:
- 32 Byte statistisch guter Zufall, der ausschliesslich für eine einzige Datei-Verschlüsselung
  verwendet wird.
- Die mittels AES-256 im Counter-Modus verschlüsselte Datei, in selber Länge wie die Orginal-Datei.
- Eine 32 Byte lange, mittels SHA-256 im HMAC-Modus über die ersten beiden Teile berechnete
  kryptografische Prüfsumme (Integritätscheckwert).


2.2.2 Zufall

Für die XorCrypt-Verschlüsselung werden 32 Byte Zufall benötigt. Diese 32 Byte werden folgendermassen verwendet:
- Die ersten 16 Byte (128 Bit) stellen den Initialisierungsvektor für die Counter-Modus-Verschlüsselung dar (IV).
- Die nächsten 8 Byte (64 Bit) fungieren als Salt-Wert für die Ableitung des AES-Schlüssels aus dem Passwort (S1).
- Die letzten 8 Byte (64 Bit) fungieren als Salt-Wert für die Ableitung des HMAC-Schlüssels aus dem Passwort (S2).

Bei einer Implementierung ist unbedingt sicherzustellen, dass jeder 32 Byte-Zufalls-Vektor nur einmal
verwendet wird. Würden 2 Dateien mit dem selben Passwort und basierend auf dem selben Zufall verschlüsselt,
wäre die Verschlüsselung aufgrund des verwendeten Counter-Modus (xor-Verknüpfung) quasi gebrochen.

2.2.3 Verschlüsselung

Die Verschlüsselung erfolgt mittels AES-256 (siehe []) im Counter-Modus (siehe []). D.h. es wird zunächst
durch Verschlüsselung des fortlaufend inkrementierten Initialisierungsvektors ein pseudozufälliger Bytestrom
erzeugt. Mit diesem wird die Orginaldatei dann bitweise xor-verknüpft. Daher rührt auch der Name XorCrypt.

Zu beachten ist, dass dabei die ersten 16 Byte (128 Bit) des pseudozufälligen Bytestromes durch AES-256
Verschlüsselung des IVs selbst erzeugt werden, alle weiter 16 Byte-Blöcke durch Verschlüsselung der inkrementierten
IV-Werte. Desweiteren ist zu beachten, dass ein Padding der Datei nicht nötig ist.


2.2.4 Integritätssicherung

Über die Verkettung der 32 Byte Zufall mit dem Chiffrat der Orginaldatei wird eine kryptografische Prüfsumme
(Integritätscheckwert) mittels SHA-256 im HMAC-Modus berechnet. Dabei kommt ein 256 Bit langer HMAC-Schlüssel
zum Einsatz. Die Prüfsumme ist 32 Byte (256 Bit) groß.


2.2.5 Schlüsselableitung

Um Brute-Force-Angriffe auf das Passwort zu erschweren, wird das Passwort nicht direkt als Schlüssel für AES-256
und HMAC-SHA-256 verwendet. Die beiden benötigten Schlüssel werden aus dem Passwort durch einen rechenintensiven
Algorithmus abgeleitet. In die Ableitung fliesst neben dem Passwort ein individueller, nur einmalig zu verwendender
64 Bit großer Salt-Wert mit ein. Als Ableitungs-Algorithmus wird PBKDF2 (siehe []) basierend auf SHA-256 verwendet.

Das Passwort darf aus maximal 63 ASCII-Zeichen bestehen, auch ein leeres Passwort (0 Byte groß) sei definiert.
Diese Festlegung dient dazu, Implementierungen eindeutig sowie zueinander kompatibel zu gestalten. Die maximal
mögliche Entropie eines Passwortes beträgt somit ca. 63 x 6 Bit = 378 Bit (Annahme: effektiv 6 Bit pro ASCII-Zeichen).
Das Passwort wird als Bytestrom (1 Byte pro ASCII-Zeichen) an die Schlüsselableitung übergeben.

Algorithmenbeschreibung PBKDF2_XORCRYPT
Eingabe:       P  (Passwort Bytestrom, Länge: 0 ... 63 Byte)
               S  (Salt-Zufallswert, Länge: 8 Byte)
Ausgabe:       K  (abgeleiteter Schlüssel, Länge: 32 Byte)
Algorithmus:   T = 00 00 00 ... 00         (32 Null-Bytes)
               U = S || 00 00 00 01        (8 Byte Salt + 4 Byte Integer-Wert 1)
               for i= 1 to 1.000.000
                 U = HMAC-SHA-256 (P, U)
                 T = T xor U               (bitweise xor-Verknüpfung, Länge T, U: je 32 Byte)
               K = T


2.2.6 Bemerkungen zur Byte-Order

In diesem Dokument wird die heutzutage in kryptografischen Standards übliche Bit- bzw. Byte-Anordung in
einem Bytestrom vorausgesetzt. D.h. das erste Bit in einem Byte ist das höchstwertige, ebenso ist das erste
Byte in einem Bytestrom / Codeblock / kryptografischen Wort immer das höchstwertige, welches an linker Stelle
geschrieben wird. Der Begriff "höchstwertig" hat natürlich nur im Falle einer numerischen Betrachtung eines
Wertes Bedeutung, z.B. beim inkrementieren des 128 Bit großen Initialisierungsvektors im Counter-Modus. Ansonsten
gilt wie bei der Schrift, Byteströme werden byteweise von links nach rechts geschrieben.



3 XorCrypt-Tool

3.1 Grundlegendes

Das XorCrypt-Tool von Jochen Ertel ist eine simple Implementierung einer Datei-Ver- und Entschlüsselung basierend
auf dem XorCrypt-Format bzw. Algorithmus (siehe Kapitel 2). Das Tool ist in C geschrieben und unter Debian-basierten
Linux-Systemen als Kommandozeilen-Applikation aus dem Quellcode baubar. Es bindet die unter Debian-Systemen
vorhandene OpenSSL-Bibliothek ein (Algorithmen AES-256 und HMAC-SHA-256).

Es wird vorausgesetzt, dass der Computer, auf dem XorCrypt verwendet wird, vetrauenswürdig ist, d.h. dass kein
potentieller Angreifer Zugriff darauf hat. Dies ist dadurch begründet, dass die Verarbeitung des Passwortes bei
und nach der Eingabe durch den Anwender nicht besonders geschützt ist. Das Passwort wird im Klartext als
Parameter übergeben und befindet sich nachher in der Bash-History sowie dem Arbeitsspeicher.

Ziel bei der Entwicklung war es ausschließlich, Dateien für die Übertragung durch das Internet sowie die
Speicherung in der Cloud oder auf externen Datenträgern abzusichern. Es war nicht Ziel, lokale Dateien auf
dem Computer vor dem Zugriff Dritter zu schützen!


3.2 Anwender-Schnittstelle

In der Version 1.0 kann man mit dem XorCrypt-Tool folgendes tun:
- Man kann einen  Selbsttest der Krypto-Funktionen durchführen, um zu sehen dass diese (AES und HMAC-SHA-256 eingebunden
  über OpenSSL) korrekt funktionieren.
- Man kann eine Datei verschlüsseln.
- Man kann eine verschlüsselte Datei ausschließlich auf Integrität prüfen.
- Man kann eine verschlüsselte Datei entschlüsseln.

Zusätzlich kann man mittels einer übergebenen Zeichenkette die 32 Byte Zufall, die bei der Verschlüsselung
benötigt und generiert werden, beeinflussen (siehe folgender Abschnitt). Die Verarbeitungsgeschwindigkeit einer
Datei kann man sich optional in Echtzeit anzeigen lassen.


3.3 Zufalls-Generierung

Für jede Datei-Verschlüsselung werden initial 32 Byte Zufall benötigt (siehe Abschnitt 2.2.2). Ausgangspunkt für deren
Erzeugung ist die aktuelle Unix-Zeit, ein Integerwert, der die vergangenen Sekunden seit dem 1. Januar 1970
anzeigt. Dieser Integerwert wird als ASCII-Zeichenkette (UnixTimeString) zum Schlüssel für eine HMAC-SHA-256 Operation,
welche die 32 Byte Zufall zum Ergebnis hat:

Random = HMAC-SHA-256 (UnixTimeString, "abc")

Die gehashte Zeichenkette "abc" kann optional durch eine beliebige andere Zeichenkette ersetzt werden. Es wird davon
ausgegangen, dass das XorCrypt-Tool niemals innerhalb einer einzigen Sekunde mehrfach aufgerufen wird. Damit ist die
Bedingung, dass die erzeugten 32 Byte Zufall niemals wiederholt verwendet werden dürfen, gegeben.



4 Test-Vektoren

4.1 Schlüsselableitung

Im Folgenden seien 4 Bespiele für die Schlüsselableitung nach Kapitel 2.2.5 gegeben. Ein Bytestrom in
Hexadezimal-Schreibweise ist stets in geschweiften Klammern angebenen. Es wird stets von den folgenden
32 Byte initialem Zufall ausgegangen:

Random = {}


4.1.1 AES-Schlüssel, leeres Passwort

S_AES = {}

Passwort = "" = {}

K_AES = PBKDF2_XORCRYPT (S_AES, P)
      = {}


4.1.2 AES-Schlüssel, gesetztes Passwort



4.1.3 HMAC-Schlüssel, leeres Passwort



4.1.2 HMAC-Schlüssel, gesetztes Passwort



4.2 Datei-Verschlüsselung

Im Folgenden ist ein Beispiel für eine Datei-Verschlüsselung gegeben.

Ausgangswerte sind:

Random = {}

Passwort = "" = {}

Datei = {}


Zwischenergebnisse sind:

K_AES = {}

K_HMAC = {}

Datei_Chiffrat = {}

Integritätscheckwert ={}


Die Ausgabe-Datei ist:

Ausgabe_Datei = Random || Datei_Chiffrat || Integritätscheckwert
              = {}




